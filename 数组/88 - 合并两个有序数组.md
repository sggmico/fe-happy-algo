## 88、合并两个有序数组

> 现有两个有序整数数组 n1 和 n2， 将n2合并到n1中，合并后n1保持有序性。

说明：

- 初始化 n1和n2的元素数量分别为 m 和 n
- 假设n1有足够的空间（空间>=m+n）来保持n2中的元素

示例：

```js
// 输入：
n1 = [1,2,3,0,0,0] 
m = 3
n2 = [2,5,6]
n = 3

// 输出：
[1,2,2,3,5,6]
```

提示：

- n1.length === m + n
- n2.length === n
- -10 ^ 9 <=  n1, n2 <= 10 ^ 9

## 分析：

### **思路1**： `先合并，再排序`

作为本题容易想到的思路。不需要额外的资源消耗，但执行效率相对较低，并没有充分利用好n1和n2原本有序的条件，可优化。

**复杂度：**

- 时间复杂度： `O((m + n) log(m + n))`
- 空间复杂度：`O(1)`

![](https://tva1.sinaimg.cn/large/0081Kckwly1gkirxam4ywj30gw02edg1.jpg)

**实现：**

```js
var merge = function(n1, m, n2, n) {
    var j = 0
    for(var i = 0; i <  m + n; i++) {
        if(i >= m && n1[i] === 0) {
            n1[i] = n2[j++]
        }
    }
    n1.sort((a, b) => a - b)
};

```

### **思路2**： `双指针，从前往后填充`

此种情况，因为n1需要作为最后结果，所以需要拷贝n1为n1_copy，并设置指针p1 和 p2，分别指向n1_copy和n2数组的第一项，然后依据大小，依次填充n1，同时移动指针，直到n1_copy和n2完全有序填充到n1后结束。该方案占用了额外的资源，空间复杂度方面不理想。

**复杂度：**

- 时间复杂度： `O(m + n)`
- 空间复杂度：`O(m)`

![](https://tva1.sinaimg.cn/large/0081Kckwly1gkirxd30bqj30h102mq36.jpg)

**实现：**

```js
var merge = function(n1, m, n2, n) {
    var p1 = p2 = 0,
        n1_copy = [...n1]
        n1.length = 0
    
    while(p1 < m && p2 < n) {
        if(n1_copy[p1] <= n2[p2]) {
            n1.push(n1_copy[p1++])
        } else {
            n1.push(n2[p2++])
        }
    }

    while(p1 < m) {
        n1.push(n1_copy[p1++])       
    }

    while(p2 < n) {
        n1.push(n2[p2++])
    }
};
```

### **思路3**： `双指针，从后往前填充`

此种情况，考虑到数组n1最后部分仅为占位项，可以用来直接填充排序后的数，无需开辟额外空间（拷贝n1）。这样可以从空间上对算法进行优化。

**复杂度：**

- 时间复杂度： `O(m + n)`
- 空间复杂度：`O(1)`

![](https://tva1.sinaimg.cn/large/0081Kckwly1gkirxbdesrj30gu02rmxe.jpg)

**实现：**

```js
var merge = function(n1, m, n2, n) {
    var p1 = m - 1,
        p2 = n - 1,
        p = m + n - 1
    
    while(p1 >= 0 && p2 >= 0) {
        if(n1[p1] <= n2[p2]) {
            n1[p--] = n2[p2--]
        } else {
            n1[p--] = n1[p1--]
        }
    }
    while(p2 >= 0) {
        n1[p--] = n2[p2--]    
    }
};
```



## 小结：

解决问题，需要充分了解和利用已知条件，并且采用巧妙的方法去不断优化算法。比如本次数组问题，通过 `双指针`、`剩余空间`（填充方向）等手段对算法进行了时间和空间复杂度上的优化，最终达到比较理想的效果。

